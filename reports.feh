uses 'console';
uses 'statistic';
uses 'ObjRunSrv';
uses 'objrunsrv-workflow';

/**
 * @namespace Reports
 * @brief Contains all Cention Reports
 */
namespace Reports {
	/**
	 * @class IncomingErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for incoming errands statistic view
	 */
	class IncomingErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Incoming');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( object timeframe )
		 * @brief Fetches data used by the getData() function
		 * @param object timeframe The timeframe in which to fetch values
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND errands.owner_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
			                     to_char((TIMESTAMP 'epoch' + errands.timestampArrive * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
			                     ${.extractFunctionCalls('errands.timestampArrive')}
			                     (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
			              FROM workflow_errands AS errands
			              LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
			              WHERE errands.timestamparrive >= ${timeframe.start}
			              AND errands.timestamparrive <= ${timeframe.end}
			              AND errands.targetarea_fkey IN (${.areas.join(',')})
			              ${agentswhereclause}
			              GROUP BY x ${.orderingFields()} g
			              ${.orderByStatement()}";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ClosedErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for closed errands statistic view
	 */
	class ClosedErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Closed');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND actions.origin_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         to_char((TIMESTAMP 'epoch' + actions.timestampwhen * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
						         ${.extractFunctionCalls('actions.timestampwhen')}
						        (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_actions AS actions
						  INNER JOIN workflow_errands AS errands ON actions.context_fkey = errands.workflow_errand_id
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id 
						  WHERE actions.type IN (3, 7)
						  AND actions.timestampwhen >= ${timeframe.start}
						  AND actions.timestampwhen <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentswhereclause}
						  GROUP BY x ${.orderingFields()} g
						  ${.orderByStatement()}";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class PublishedErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for published errands statistic view
	 */
	class PublishedErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Published');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND errands.owner_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         to_char((TIMESTAMP 'epoch' + answers.timestampcreated * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
						         ${.extractFunctionCalls('answers.timestampcreated')}
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_answers AS answers
						  INNER JOIN workflow_errands AS errands ON answers.workflow_answer_id = errands.answer_fkey
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						  INNER JOIN workflow_errand_tags_links AS errand_tags_links ON errands.workflow_errand_id = errand_tags_links.parent_workflow_errand_id
						  INNER JOIN workflow_tags AS tags ON errand_tags_links.child_workflow_tag_id = tags.workflow_tag_id
						  WHERE tags.name = 'system.errand.published.yes'
						  AND answers.timestampcreated >= ${timeframe.start}
						  AND answers.timestampcreated <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentswhereclause}
						  GROUP BY x ${.orderingFields()} g
						  ${.orderByStatement()}";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ClosedErrandsWithReplies
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for closed errands with replies statistic view
	 */
	// Replies
	class ClosedErrandsWithReplies extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Replies');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND errands.owner_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         to_char((TIMESTAMP 'epoch' + errands.timestamparrive * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
						         ${.extractFunctionCalls('errands.timestamparrive')}
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						         FROM workflow_errands AS errands
						         LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						         WHERE errands.parent_fkey > 0
						         AND errands.timestamparrive >= ${timeframe.start}
						         AND errands.timestamparrive <= ${timeframe.end}
						         AND errands.targetarea_fkey IN (${.areas.join(',')})
						         ${agentswhereclause}
						         GROUP BY x ${.orderingFields()} g
						         ${.orderByStatement()}";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandClosureStatus
	 * @extends Statistic.AgentView
	 * @brief Handles data needed for errand closure status statistic view
	 */
	class ErrandClosureStatus extends Statistic.AgentView {
		string name;
		
		constructor {
			super();
			.name = I('Closure status');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND actions.origin_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(actions.context_fkey) AS y,
			                     users.username AS x,
			                     (CASE WHEN actions.type = 3 THEN 'Answered'
			                           WHEN actions.type = 4 THEN 'Forwarded to agent'
			                           WHEN actions.type = 8 THEN 'Returned'
			                           WHEN actions.type = 7 THEN 'Deleted'
						               WHEN actions.type = 5 THEN 'Forwarded to area'
			                           WHEN actions.type = 6 THEN 'Moved to folder' END) AS g
			              FROM workflow_actions AS actions
			              INNER JOIN workflow_errands AS errands ON actions.context_fkey = errands.workflow_errand_id
			              INNER JOIN workflow_users AS users ON actions.origin_fkey = users.workflow_user_id
			              WHERE actions.type IN (3, 4, 5, 6, 7, 8)
			              AND actions.timestampwhen >= ${timeframe.start}
			              AND actions.timestampwhen <= ${timeframe.end}
			              AND errands.targetarea_fkey IN (${.areas.join(',')})
			              ${agentswhereclause}
			              GROUP BY x, g
			              ORDER BY x";
			.setGroups(['Answered'           => I('Answered'),
			            'Forwarded to agent' => I('Forwarded to agent'),
			            'Returned'           => I('Returned'),
			            'Deleted'            => I('Deleted'),
			            'Forwarded to area'  => I('Forwarded to area'),
			            'Moved to folder'    => I('Moved to folder')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandResponseTime
	 * @extends Statistic.RelativeTimeView
	 * @brief Handles data needed for response time statistic view
	 */
	class ErrandResponseTime extends Statistic.RelativeTimeView {
		string name;
		string key;
		
		constructor {
			super();
			.name = I('Response time');
			.key = I('Response time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND actions.origin_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(actions.context_fkey) AS y,
						         ((actions.timestampwhen - errands.timestamparrive) / (${.outputTime.seconds})) AS x,
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_actions AS actions
						  INNER JOIN workflow_errands AS errands ON actions.context_fkey = errands.workflow_errand_id
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						  WHERE actions.type IN (3, 7)
						  AND actions.timestampwhen >= ${timeframe.start}
						  AND actions.timestampwhen <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentswhereclause}
						  GROUP BY x, g
						  ORDER BY x";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandProcessTime
	 * @extends Statistic.RelativeTimeView
	 * @brief Handles data needed for errand process time statistic view
	 */
	class ErrandProcessTime extends Statistic.RelativeTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Process time');
			.key = I('Process time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND actions.origin_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(actions.context_fkey) AS y,
						         (sum(actions.timestampWhen - 
						              (SELECT actions2.timestampwhen
						               FROM workflow_actions AS actions2
						               WHERE actions2.type = 2
						               AND actions2.timestampwhen <= actions.timestampwhen
						               AND actions2.context_fkey = actions.context_fkey
						               ORDER BY actions2.timestampwhen DESC
						               LIMIT 1)) / (${.outputTime.seconds})) AS x,
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_actions AS actions
						  INNER JOIN workflow_errands AS errands ON actions.context_fkey = errands.workflow_errand_id
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						  WHERE actions.type IN (3, 4, 5, 6, 7, 8)
						  AND actions.timestampwhen >= ${timeframe.start}
						  AND actions.timestampwhen <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentswhereclause}
						  GROUP BY g
						  ORDER BY x";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AverageErrandResponseTime
	 * @extendsStatistic.AreaRelativeTimeView
	 * @brief Handles data needed for average errand response time statistic view
	 */
	class AverageErrandResponseTime extends Statistic.AreaRelativeTimeView {
		string name = "Average response time";
		
		constructor {
			super();
			.name = I('Average response time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND actions.origin_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT areas.name AS x,
			                     ((sum(actions.timestampwhen - errands.timestamparrive) / (${.outputTime.seconds})) / count(actions.context_fkey)) AS y,
			                     'Errands' AS g
			              FROM workflow_actions AS actions
			              INNER JOIN workflow_errands AS errands ON actions.context_fkey = errands.workflow_errand_id
			              INNER JOIN workflow_areas AS areas ON errands.targetarea_fkey = areas.workflow_area_id
			              WHERE actions.type IN (3, 7)
			              AND actions.timestampwhen >= ${timeframe.start}
			              AND actions.timestampwhen <= ${timeframe.end}
			              AND errands.targetarea_fkey IN (${.areas.join(',')})
			              ${agentswhereclause}
			              GROUP BY x, g
			              ORDER BY x ASC;";
			.setGroups(['Errands' => I('Errands')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AverageErrandProcessTime
	 * @extends Statistic.AgentRelativeTimeView
	 * @brief Handles data needed for average errand process time statistic view
	 */
	class AverageErrandProcessTime extends Statistic.AgentRelativeTimeView {
		string name = "Average process time";
		
		constructor {
			super();
			.name = I('Average process time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND actions.origin_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT users.username AS x,
			                     (sum(actions.timestampwhen -
			                      (SELECT actions2.timestampwhen
			                       FROM workflow_actions AS actions2
			                       WHERE actions2.type = 2
			                       AND actions2.timestampwhen <= actions.timestampwhen
			                       AND actions2.origin_fkey = actions.origin_fkey
			                       AND actions2.context_fkey = actions.context_fkey
			                       ORDER BY actions2.timestampwhen DESC
			                       LIMIT 1)) / (${.outputTime.seconds}) ) / count(actions.context_fkey) AS y,
			                     'Errands' as g
			              FROM workflow_actions AS actions
			              INNER JOIN workflow_users AS users ON actions.origin_fkey = users.workflow_user_id
			              INNER JOIN workflow_errands AS errands ON actions.context_fkey = errands.workflow_errand_id
			              WHERE actions.type IN (3, 4, 5, 6, 7, 8)
			              AND actions.timestampwhen >= ${timeframe.start}
			              AND actions.timestampwhen <= ${timeframe.end}
			              AND errands.targetarea_fkey IN (${.areas.join(',')})
			              ${agentswhereclause}
			              GROUP BY x, g
			              ORDER BY x ASC";
			.setGroups(['Errands' => I('Errands')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	class ErrandClassification extends Statistic.ActionView {
		string name;
		
		constructor {
			super();
			.name = I('Classification');
			.key = I('Classification');
		}
		
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND errands.owner_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         tags.display as X,
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_tags AS tags
						  INNER JOIN workflow_errand_tags_links AS errand_tags_links ON tags.workflow_tag_id = errand_tags_links.child_workflow_tag_id
						  INNER JOIN workflow_errands AS errands ON errand_tags_links.parent_workflow_errand_id = errands.workflow_errand_id
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						  WHERE substr(tags.name, 1, 7) = 'client.'
						  AND errands.timestamparrive >= ${timeframe.start}
						  AND errands.timestamparrive <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentswhereclause}
						  GROUP BY x, g
						  ORDER BY x";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	
	class QuickAsk extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Quick Ask');
		}
		
		function fetchData( object timeframe ) {
			string sql = "SELECT count(log.quickask_log_id) AS y,
			                     to_char((TIMESTAMP 'epoch' + log.timestampwhen * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
			                     ${.extractFunctionCalls('log.timestampwhen')}
			                     'Quick Ask Question' as g
			              FROM quickask_logs AS log
			              WHERE log.searchtype = 1
			              AND log.timestampwhen >= ${timeframe.start}
			              AND log.timestampwhen <= ${timeframe.end}
			              GROUP BY x ${.orderingFields()} g
			              ${.orderByStatement()}";
			.setGroups(['Quick Ask Question' => I('Quick Ask Question')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	
	class QuickAskQuestions extends Statistic.ActionView {
		string name;
		
		constructor {
			.name = I('Quick Ask Questions');
			.key = I('Question');
		}
		
		function fetchData( object timeframe ) {
			string sql = "SELECT count(log.quickask_log_id) AS y,
			                     questions.tag AS x,
			                     'Quick Ask Question' AS g
			              FROM quickask_logs AS log
			              INNER JOIN quickask_log_matchingtemplates_links AS matches_links ON log.quickask_log_id = parent_quickask_log_id
			              INNER JOIN quickask_matchingtemplates AS matches ON child_quickask_matchingtemplate_id = matches.quickask_matchingtemplate_id
			              INNER JOIN quickask_questions AS questions ON matches.question = questions.quickask_question_id
			              WHERE log.searchtype = 1
			              AND log.timestampwhen >= ${timeframe.start}
			              AND log.timestampwhen <= ${timeframe.end}
			              GROUP BY x, g
			              ORDER BY x";
			.setGroups(['Quick Ask Question' => I('Quick Ask Question')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	
	class QuickAskTemplates extends Statistic.ActionView {
		string name;
		
		constructor {
			.name = I('Quick Ask Templates');
			.key = I('Template');
		}
		
		function fetchData( object timeframe ) {
			string sql = "SELECT count(log.quickask_log_id) AS y,
			                     templates.tag AS x,
			                     'Quick Ask Question' AS g
			              FROM quickask_logs AS log
			              INNER JOIN quickask_log_matchingtemplates_links AS matches_links ON log.quickask_log_id = parent_quickask_log_id
			              INNER JOIN quickask_matchingtemplates AS matches ON child_quickask_matchingtemplate_id = matches.quickask_matchingtemplate_id
			              INNER JOIN quickask_templates AS templates ON matches.template = templates.quickask_template_id
			              WHERE log.searchtype = 1
			              AND log.timestampwhen >= ${timeframe.start}
			              AND log.timestampwhen <= ${timeframe.end}
			              GROUP BY x, g
			              ORDER BY x";
			.setGroups(['Quick Ask Question' => I('Quick Ask Question')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
}
/**
 * @end
 */

