uses 'console';
uses 'statistic';
uses 'ObjRunSrv';
uses 'objrunsrv-workflow';

/**
 * @namespace Reports
 * @brief Contains all Cention Reports
 */
namespace Reports {
	/**
	 * @class IncomingErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for incoming errands statistic view
	 */
	class IncomingErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Incoming');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( object timeframe )
		 * @brief Fetches data used by the getData() function
		 * @param object timeframe The timeframe in which to fetch values
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND errands.owner_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
			                     to_char((TIMESTAMP 'epoch' + errands.timestampArrive * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
			                     ${.extractFunctionCalls('errands.timestampArrive')}
			                     (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
			              FROM workflow_errands AS errands
			              LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
			              WHERE errands.timestamparrive >= ${timeframe.start}
			              AND errands.timestamparrive <= ${timeframe.end}
			              AND errands.targetarea_fkey IN (${.areas.join(',')})
			              ${agentswhereclause}
			              GROUP BY x ${.orderingFields(true)} g
			              ORDER BY ${.orderingFields()}";
			              print(sql);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ClosedErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for closed errands statistic view
	 */
	class ClosedErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Closed');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND actions.origin_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         to_char((TIMESTAMP 'epoch' + actions.timestampwhen * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
						         ${.extractFunctionCalls('actions.timestampwhen')}
						        (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_actions AS actions
						  INNER JOIN workflow_errands AS errands ON actions.context_fkey = errands.workflow_errand_id
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id 
						  WHERE actions.type IN (3, 7)
						  AND actions.timestampwhen >= ${timeframe.start}
						  AND actions.timestampwhen <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentswhereclause}
						  GROUP BY x ${.orderingFields(true)} g
						  ORDER BY ${.orderingFields()}";
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class PublishedErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for published errands statistic view
	 */
	class PublishedErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Published');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND errands.owner_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         to_char((TIMESTAMP 'epoch' + answers.timestampcreated * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
						         ${.extractFunctionCalls('answers.timestampcreated')}
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_answers AS answers
						  INNER JOIN workflow_errands AS errands ON answers.workflow_answer_id = errands.answer_fkey
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						  INNER JOIN workflow_errand_tags_links AS errand_tags_links ON errands.workflow_errand_id = errand_tags_links.parent_workflow_errand_id
						  INNER JOIN workflow_tags AS tags ON errand_tags_links.child_workflow_tag_id = tags.workflow_tag_id
						  WHERE tags.name = 'system.errand.published.yes'
						  AND answers.timestampcreated >= ${timeframe.start}
						  AND answers.timestampcreated <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentswhereclause}
						  GROUP BY x ${.orderingFields(true)} g
						  ORDER BY ${.orderingFields()}";
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ClosedErrandsWithReplies
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for closed errands with replies statistic view
	 */
	// Replies
	class ClosedErrandsWithReplies extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Replies');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND errands.owner_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         to_char((TIMESTAMP 'epoch' + errands.timestamparrive * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
						         ${.extractFunctionCalls('errands.timestamparrive')}
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						         FROM workflow_errands AS errands
						         LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						         WHERE errands.parent_fkey > 0
						         AND errands.timestamparrive >= ${timeframe.start}
						         AND errands.timestamparrive <= ${timeframe.end}
						         AND errands.targetarea_fkey IN (${.areas.join(',')})
						         ${agentswhereclause}
						         GROUP BY x ${.orderingFields(true)} g
						         ORDER BY ${.orderingFields()}";
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandClosureStatus
	 * @extends Statistic.AgentView
	 * @brief Handles data needed for errand closure status statistic view
	 */
	class ErrandClosureStatus extends Statistic.AgentView {
		string name;
		
		constructor {
			super();
			.name = I('Closure status');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			array answered = [];
			array deleted = [];
			array returned = [];
			array agent = [];
			array area = [];
			array folder = [];
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				answered = Workflow.Errand.closureStatusAnsweredReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				deleted  = Workflow.Errand.closureStatusDeletedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				returned = Workflow.Errand.closureStatusReturnedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				agent    = Workflow.Errand.closureStatusForwardedToAgentReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				area     = Workflow.Errand.closureStatusForwardedToAreaReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				if( F('folders') ) {
					folder   = Workflow.Errand.closureStatusForwardedToFolderReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				}
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				Workflow.Errand.closureStatusAnsweredReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
					if( not answered.keyExists(key) )
						answered[key] = 0;
					answered[key] += value;
				};
				Workflow.Errand.closureStatusDeletedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
					if( not deleted.keyExists(key) )
						deleted[key] = 0;
					deleted[key] += value;
				};
				Workflow.Errand.closureStatusReturnedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
					if( not returned.keyExists(key) )
						returned[key] = 0;
					returned[key] += value;
				};
				Workflow.Errand.closureStatusForwardedToAgentReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
					if( not agent.keyExists(key) )
						agent[key] = 0;
					agent[key] += value;
				};
				Workflow.Errand.closureStatusForwardedToAreaReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
					if( not area.keyExists(key) )
						area[key] = 0;
					area[key] += value;
				};
				if( F('folders') ) {
					Workflow.Errand.closureStatusForwardedToFolderReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
						if( not folder.keyExists(key) )
							folder[key] = 0;
						folder[key] += value;
					};
				}
			}
			answered.keys().each() using ( key ) {
				if( not deleted.keyExists(key) )
					deleted[key] = 0;
				if( not returned.keyExists(key) )
					returned[key] = 0;
				if( not area.keyExists(key) )
					area[key] = 0;
				if( not agent.keyExists(key) )
					agent[key] = 0;
				if( not folder.keyExists(key) )
					folder[key] = 0;
			};
			deleted.keys().each() using ( key ) {
				if( not answered.keyExists(key) )
					answered[key] = 0;
				if( not returned.keyExists(key) )
					returned[key] = 0;
				if( not area.keyExists(key) )
					area[key] = 0;
				if( not agent.keyExists(key) )
					agent[key] = 0;
				if( not folder.keyExists(key) )
					folder[key] = 0;
			};
			returned.keys().each() using ( key ) {
				if( not answered.keyExists(key) )
					deleted[key] = 0;
				if( not deleted.keyExists(key) )
					deleted[key] = 0;
				if( not area.keyExists(key) )
					area[key] = 0;
				if( not agent.keyExists(key) )
					agent[key] = 0;
				if( not folder.keyExists(key) )
					folder[key] = 0;
			};
			area.keys().each() using ( key ) {
				if( not answered.keyExists(key) )
					deleted[key] = 0;
				if( not deleted.keyExists(key) )
					deleted[key] = 0;
				if( not returned.keyExists(key) )
					returned[key] = 0;
				if( not agent.keyExists(key) )
					agent[key] = 0;
				if( not folder.keyExists(key) )
					folder[key] = 0;
			};
			agent.keys().each() using ( key ) {
				if( not answered.keyExists(key) )
					deleted[key] = 0;
				if( not deleted.keyExists(key) )
					deleted[key] = 0;
				if( not returned.keyExists(key) )
					returned[key] = 0;
				if( not area.keyExists(key) )
					area[key] = 0;
				if( not folder.keyExists(key) )
					folder[key] = 0;
			};
			if( F('folders') ) {
				folder.keys().each() using ( key ) {
					if( not answered.keyExists(key) )
						deleted[key] = 0;
					if( not deleted.keyExists(key) )
						deleted[key] = 0;
					if( not returned.keyExists(key) )
						returned[key] = 0;
					if( not area.keyExists(key) )
						area[key] = 0;
					if( not agent.keyExists(key) )
						agent[key] = 0;
				};
			}
			.addDataGroup( I('Answered'), answered );
			.addDataGroup( I('Deleted'), deleted );
			.addDataGroup( I('Returned'), returned );
			.addDataGroup( I('Forwarded to agent'), agent );
			.addDataGroup( I('Forwarded to area'), area );
			if( F('folders') ) {
				.addDataGroup( I('Moved to folder'), folder );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandResponseTime
	 * @extends Statistic.RelativeTimeView
	 * @brief Handles data needed for response time statistic view
	 */
	class ErrandResponseTime extends Statistic.RelativeTimeView {
		string name;
		string key;
		
		constructor {
			super();
			.name = I('Response time');
			.key = I('Response time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND actions.origin_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         ((actions.timestampwhen - errands.timestamparrive) / (${.outputTime.seconds})) AS x,
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_actions AS actions
						  INNER JOIN workflow_errands AS errands ON actions.context_fkey = errands.workflow_errand_id
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						  WHERE actions.type IN (3, 7)
						  AND actions.timestampwhen >= ${timeframe.start}
						  AND actions.timestampwhen <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentswhereclause}
						  GROUP BY x, g
						  ORDER BY x";
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandProcessTime
	 * @extends Statistic.RelativeTimeView
	 * @brief Handles data needed for errand process time statistic view
	 */
	class ErrandProcessTime extends Statistic.RelativeTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Process time');
			.key = I('Process time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentswhereclause = ( .agents ? "AND actions.origin_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         (sum(actions.timestampWhen - 
						              (SELECT actions2.timestampwhen
						               FROM workflow_actions AS actions2
						               WHERE actions2.type = 2
						               AND actions2.timestampwhen <= actions.timestampwhen
						               AND actions2.context_fkey = actions.context_fkey
						               ORDER BY actions2.timestampwhen DESC
						               LIMIT 1)) / (${.outputTime.seconds})) AS x,
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_actions AS actions
						  INNER JOIN workflow_errands AS errands ON actions.context_fkey = errands.workflow_errand_id
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						  WHERE actions.type IN (3, 4, 5, 6, 7, 8)
						  AND actions.timestampwhen >= ${timeframe.start}
						  AND actions.timestampwhen <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentswhereclause}
						  GROUP BY g
						  ORDER BY x";
              return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AverageErrandResponseTime
	 * @extendsStatistic.AreaRelativeTimeView
	 * @brief Handles data needed for average errand response time statistic view
	 */
	class AverageErrandResponseTime extends Statistic.AreaRelativeTimeView {
		string name = "Average response time";
		
		constructor {
			super();
			.name = I('Average response time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				array email = Workflow.Errand.averageResponseTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				.addDataGroup( I('Email'), email );
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				array manual = Workflow.Errand.averageResponseTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents );
				.addDataGroup( I('Manual'), manual );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AverageErrandProcessTime
	 * @extends Statistic.AgentRelativeTimeView
	 * @brief Handles data needed for average errand process time statistic view
	 */
	class AverageErrandProcessTime extends Statistic.AgentRelativeTimeView {
		string name = "Average process time";
		
		constructor {
			super();
			.name = I('Average process time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				array email = Workflow.Errand.averageProcessTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				.addDataGroup( I('Email'), email );
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				array manual = Workflow.Errand.averageProcessTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents );
				.addDataGroup( I('Manual'), manual );
			}
		}
	}
	/**
	 * @end
	 */
	
	class ErrandClassification extends Statistic.ActionView {
		string name;
		
		constructor {
			super();
			.name = I('Classification');
			.key = I('Classification');
		}
		
		function parseValues( array& values ) {
			array newValues = [];
			object r = new Regexp( 'client\.\[(.*)\]' );
			values.map() using ( key, value ) {
				if( not key.nCompareCase( 'system.', 7 ) ) {
					key = r.replaceAll( key ) using ( match ) {
						array captures = match.captures();
						return captures[0];
					};
					newValues[key] = value;
				}
			};
			return newValues;
		}
				
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL )
				.addDataGroup( I('Email'), .parseValues( Workflow.Errand.classificationReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents ) ) );
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL )
				.addDataGroup( I('Manual'), .parseValues( Workflow.Errand.classificationReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ) ) );
		}
	}
}
/**
 * @end
 */

