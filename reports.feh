uses 'console';
uses 'statistic';
uses 'ObjRunSrv';
uses 'objrunsrv-workflow';

/**
 * @namespace Reports
 * @brief Contains all Cention Reports
 */
namespace Reports {
	/**
	 * @class IncomingErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for incoming errands statistic view
	 */
	class IncomingErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Incoming');
			.workflow = true;
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( object timeframe )
		 * @brief Fetches data used by the getData() function
		 * @param object timeframe The timeframe in which to fetch values
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND data.user_id IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errand_id) AS y,
			              to_char((TIMESTAMP 'epoch' + (data.timestamp_arrive + INTEGER '${(Config.TimeZoneOffset * 2) * 60}') * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
			              ${.extractFunctionCalls('data.timestamp_arrive')}
			              (CASE WHEN data.service_id = 0 THEN 'Email' ELSE services.name END) AS g
			              FROM workflow_reporterranddatas AS data
			              LEFT JOIN workflow_services AS services ON data.service_id = services.workflow_service_id
			              WHERE data.timestamp_arrive >= ${timeframe.start}
			              AND data.timestamp_arrive <= ${timeframe.end}
			              AND data.area_id IN (${.areas.join(',')})
			              ${agentsWhereClause}
			              ${.serviceWhereClause()}
			              GROUP BY x ${.orderingFields()} g
			              ${.orderByStatement()}";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ClosedErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for closed errands statistic view
	 */
	class ClosedErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Closed');
			.workflow = true;
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND data.user_id IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(data.errand_id) AS y,
			                     sum(data.timestamp_close + ${(Config.TimeZoneOffset * 2) * 60}) AS tobbe,
						         to_char((TIMESTAMP 'epoch' + (data.timestamp_close + INTEGER '${(Config.TimeZoneOffset * 2) * 60}') * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
						         ${.extractFunctionCalls('data.timestamp_close')}
						        (CASE WHEN data.service_id = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_reporterranddatas AS data
						  LEFT JOIN workflow_services AS services ON data.service_id = services.workflow_service_id 
						  WHERE data.timestamp_close > 0
						  AND data.timestamp_close >= ${timeframe.start}
						  AND data.timestamp_close <= ${timeframe.end}
						  AND data.area_id IN (${.areas.join(',')})
						  ${agentsWhereClause}
						  ${.serviceWhereClause()}
						  GROUP BY x ${.orderingFields()} g
						  ${.orderByStatement()}";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class PublishedErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for published errands statistic view
	 */
	class PublishedErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Published');
			.workflow = true;
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND errands.owner_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         to_char((TIMESTAMP 'epoch' + (answers.timestampcreated + INTEGER '${(Config.TimeZoneOffset * 2) * 60}') * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
						         ${.extractFunctionCalls('answers.timestampcreated')}
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_answers AS answers
						  INNER JOIN workflow_errands AS errands ON answers.workflow_answer_id = errands.answer_fkey
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						  INNER JOIN workflow_errand_tags_links AS errand_tags_links ON errands.workflow_errand_id = errand_tags_links.parent_workflow_errand_id
						  INNER JOIN workflow_tags AS tags ON errand_tags_links.child_workflow_tag_id = tags.workflow_tag_id
						  WHERE tags.name = 'system.errand.published.yes'
						  AND answers.timestampcreated >= ${timeframe.start}
						  AND answers.timestampcreated <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentsWhereClause}
						  ${.serviceWhereClause()}
						  GROUP BY x ${.orderingFields()} g
						  ${.orderByStatement()}";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ClosedErrandsWithReplies
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for closed errands with replies statistic view
	 */
	// Replies
	class ClosedErrandsWithReplies extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Replies');
			.workflow = true;
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND data.user_id IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(data.errand_id) AS y,
						         to_char((TIMESTAMP 'epoch' + (data.timestamp_close + INTEGER '${(Config.TimeZoneOffset * 2) * 60}') * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
						         ${.extractFunctionCalls('data.timestamp_close')}
						         (CASE WHEN data.service_id = 0 THEN 'Email' ELSE services.name END) AS g
						         FROM workflow_reporterranddatas AS data
						         LEFT JOIN workflow_services AS services ON data.service_id = services.workflow_service_id
						         WHERE data.timestamp_replied > 0
						         AND data.timestamp_close >= ${timeframe.start}
						         AND data.timestamp_close <= ${timeframe.end}
						         AND data.area_id IN (${.areas.join(',')})
						         ${agentsWhereClause}
						         ${.serviceWhereClause()}
						         GROUP BY x ${.orderingFields()} g
						         ${.orderByStatement()}";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandClosureStatus
	 * @extends Statistic.AgentView
	 * @brief Handles data needed for errand closure status statistic view
	 */
	class ErrandClosureStatus extends Statistic.AgentView {
		string name;
		
		constructor {
			super();
			.name = I('Closure status');
			.workflow = true;
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND actions.origin_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(actions.workflow_action_id) AS y,
			                     users.username AS x,
			                     (CASE WHEN actions.type = 3 THEN 'Answered'
			                           WHEN actions.type = 4 THEN 'Forwarded to agent'
			                           WHEN actions.type = 8 THEN 'Returned'
			                           WHEN actions.type = 7 THEN 'Deleted'
						               WHEN actions.type = 5 THEN 'Forwarded to area'
			                           WHEN actions.type = 6 THEN 'Moved to folder' END) AS g
			              FROM workflow_errands AS errands
			              INNER JOIN workflow_errand_actions_links ON parent_workflow_errand_id = errands.workflow_errand_id
			              INNER JOIN workflow_actions AS actions ON child_workflow_action_id = actions.workflow_action_id
			              INNER JOIN workflow_users AS users ON actions.origin_fkey = users.workflow_user_id
			              WHERE actions.type IN (3, 4, 5, 6, 7, 8)
			              AND actions.timestampwhen >= ${timeframe.start}
			              AND actions.timestampwhen <= ${timeframe.end}
			              AND errands.targetarea_fkey IN (${.areas.join(',')})
			              ${agentsWhereClause}
			              ${.serviceWhereClause()}
			              GROUP BY x, g
			              ORDER BY x";
			.setGroups(['Answered'           => I('Answered'),
			            'Forwarded to agent' => I('Forwarded to agent'),
			            'Returned'           => I('Returned'),
			            'Deleted'            => I('Deleted'),
			            'Forwarded to area'  => I('Forwarded to area'),
			            'Moved to folder'    => I('Moved to folder')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandResponseTime
	 * @extends Statistic.RelativeTimeView
	 * @brief Handles data needed for response time statistic view
	 */
	class ErrandResponseTime extends Statistic.RelativeTimeView {
		string name;
		string key;
		
		constructor {
			super();
			.name = I('Response time');
			.key = I('Response time');
			.workflow = true;
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND data.user_id IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(data.errand_id) AS y,
			                     data.response_time / ${.outputTime.seconds} AS x,
						         (CASE WHEN data.service_id = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_reporterranddatas AS data
						  LEFT JOIN workflow_services AS services ON data.service_id = services.workflow_service_id
						  WHERE timestamp_close > 0
						  AND data.timestamp_close >= ${timeframe.start}
						  AND data.timestamp_close <= ${timeframe.end}
						  AND data.area_id IN (${.areas.join(',')})
						  ${agentsWhereClause}
						  ${.serviceWhereClause()}
						  GROUP BY x, g
						  ORDER BY x";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandProcessTime
	 * @extends Statistic.RelativeTimeView
	 * @brief Handles data needed for errand process time statistic view
	 */
	class ErrandProcessTime extends Statistic.RelativeTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Process time');
			.key = I('Process time');
			.workflow = true;
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND data.user_id IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(data.errand_id) AS y,
			                     data.process_time / ${.outputTime.seconds} AS x,
						         (CASE WHEN data.service_id = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_reporterranddatas AS data
						  LEFT JOIN workflow_services AS services ON data.service_id = services.workflow_service_id
						  WHERE data.timestamp_close > 0
						  AND data.timestamp_arrive >= ${timeframe.start}
						  AND data.timestamp_arrive <= ${timeframe.end}
						  AND data.area_id IN (${.areas.join(',')})
						  ${agentsWhereClause}
						  ${.serviceWhereClause()}
						  GROUP BY x, g
						  ORDER BY x";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AverageErrandResponseTime
	 * @extendsStatistic.AreaRelativeTimeView
	 * @brief Handles data needed for average errand response time statistic view
	 */
	class AverageErrandResponseTime extends Statistic.AreaRelativeTimeView {
		string name = "Average response time";
		
		constructor {
			super();
			.name = I('Average response time');
			.workflow = true;
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND data.user_id IN (${.agents.join(',')})" : '' );
			string sql = "SELECT areas.name AS x,
			                     floor(avg(data.response_time) / ${.outputTime.seconds}) AS y,
			                     'Average Time' AS g
			              FROM workflow_reporterranddatas AS data
			              INNER JOIN workflow_areas AS areas ON data.area_id = areas.workflow_area_id
			              WHERE data.timestamp_close > 0
			              AND data.timestamp_close >= ${timeframe.start}
			              AND data.timestamp_close <= ${timeframe.end}
			              AND data.area_id IN (${.areas.join(',')})
			              ${agentsWhereClause}
			              ${.serviceWhereClause()}
			              GROUP BY x
			              ORDER BY x ASC;";
			.setGroups(['Average Time' => I('Average Time')]);
			.setAverage(true);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AverageErrandProcessTime
	 * @extends Statistic.AgentRelativeTimeView
	 * @brief Handles data needed for average errand process time statistic view
	 */
	class AverageErrandProcessTime extends Statistic.AgentRelativeTimeView {
		string name = "Average process time";
		
		constructor {
			super();
			.name = I('Average process time');
			.workflow = true;
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND data.user_id IN (${.agents.join(',')})" : '' );
			string sql = "SELECT users.username AS x,
			                     floor(avg(data.process_time) / ${.outputTime.seconds}) AS y,
			                     'Average Time' AS g
			              FROM workflow_reportuserdatas AS data
			              JOIN workflow_users AS users ON users.workflow_user_id = data.user_id
			              WHERE data.timestamp_open >= ${timeframe.start}
			              AND data.timestamp_open <= ${timeframe.end}
			              AND data.area_id IN (${.areas.join(',')})
			              ${agentsWhereClause}
			              GROUP BY x
			              ORDER BY x ASC";
			.setGroups(['Average Time' => I('Average Time')]);
			.setAverage(true);
			return ObjRunObject.rawQuery(sql);
		}
	}
	/**
	 * @end
	 */
	
	class ErrandSLATime extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('SLA time');
			.workflow = true;
		}
		
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND data.user_id IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(data.errand_id) AS y,
			                     to_char((TIMESTAMP 'epoch' + (data.timestamp_close + INTEGER '${(Config.TimeZoneOffset * 2) * 60}') * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
			                     ${.extractFunctionCalls('data.timestamp_close')}
			                     (CASE WHEN data.response_time <= (areas.generalalerttime * 60) THEN 'Responded according to SLA time' ELSE 'Responded after SLA time' END) AS g
			              FROM workflow_reporterranddatas AS data
			              INNER JOIN workflow_areas AS areas ON data.area_id = areas.workflow_area_id
			              WHERE data.timestamp_close > 0
			              AND data.timestamp_close >= ${timeframe.start}
			              AND data.timestamp_close <= ${timeframe.end}
			              AND data.area_id IN (${.areas.join(',')})
			              ${agentsWhereClause}
			              ${.serviceWhereClause()}
			              GROUP BY x ${.orderingFields()} g
			              ${.orderByStatement()}";
			.setGroups(['Responded according to SLA time' => I('Responded according to SLA time'), 'Responded after SLA time' => I('Responded after SLA time')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	
	class ErrandClassification extends Statistic.ActionView {
		string name;
		
		constructor {
			super();
			.name = I('Classification');
			.key = I('Classification');
		}
		
		function fetchData( object timeframe ) {
			string agentsWhereClause = ( .agents ? "AND errands.owner_fkey IN (${.agents.join(',')})" : '' );
			string sql = "SELECT count(errands.workflow_errand_id) AS y,
						         tags.display as X,
						         (CASE WHEN errands.service_fkey = 0 THEN 'Email' ELSE services.name END) AS g
						  FROM workflow_tags AS tags
						  INNER JOIN workflow_errand_tags_links AS errand_tags_links ON tags.workflow_tag_id = errand_tags_links.child_workflow_tag_id
						  INNER JOIN workflow_errands AS errands ON errand_tags_links.parent_workflow_errand_id = errands.workflow_errand_id
						  LEFT JOIN workflow_services AS services ON errands.service_fkey = services.workflow_service_id
						  WHERE substr(tags.name, 1, 7) = 'client.'
						  AND errands.timestamparrive >= ${timeframe.start}
						  AND errands.timestamparrive <= ${timeframe.end}
						  AND errands.targetarea_fkey IN (${.areas.join(',')})
						  ${agentsWhereClause}
						  ${.serviceWhereClause()}
						  GROUP BY x, g
						  ORDER BY x";
			.setGroups(['Email' => I('Email'), 'Manual' => I('Manual')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	
	class QuickAskQuestions extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Quick Ask Questions');
			.textEngine = true;
		}
		
		function fetchData( object timeframe ) {
			string sql = "SELECT count(distinct quickask_log_id) AS y,
			                     to_char((TIMESTAMP 'epoch' + (logs.timestampwhen + INTEGER '${(Config.TimeZoneOffset * 2) * 60}') * INTERVAL '1 second'), '${.outputTime.pgsqlFormat()}') AS x,
			                     ${.extractFunctionCalls('logs.timestampwhen')}
			                     (CASE WHEN matchingtemplates.matchtype IN (1, 2) THEN 'Answered' ELSE 'Unanswered' END) AS g
			              FROM quickask_logs AS logs
			              LEFT JOIN quickask_log_matchingtemplates_links AS matchingtemplates_links ON logs.quickask_log_id = matchingtemplates_links.parent_quickask_log_id
			              LEFT JOIN quickask_matchingtemplates AS matchingtemplates ON matchingtemplates_links.child_quickask_matchingtemplate_id = matchingtemplates.quickask_matchingtemplate_id
			              LEFT JOIN quickask_questions AS questions ON matchingtemplates.question = questions.quickask_question_id
			              WHERE logs.searchtype = 1
			              AND logs.timestampwhen >= ${timeframe.start}
			              AND logs.timestampwhen <= ${timeframe.end}
			              AND logs.textEngine IN (${.textEngines.join(',')})
			              GROUP BY x ${.orderingFields()} g
			              ${.orderByStatement()}";
			.setGroups(['Answered' => I('Answered'), 'Unanswered' => I('Unanswered')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
	
	class QuickAskAnswers extends Statistic.ActionView {
		string name;
		
		constructor {
			super();
			.name = I('Quick Ask Answers');
			.textEngine = true;
		}
		
		function fetchData( object timeframe ) {
			string sql = "SELECT count(logs.quickask_log_id) AS y,
			                     questions.tag AS x,
			                     (CASE WHEN matchingtemplates.matchtype = 1 THEN 'Close Answer' ELSE 'Related Answer' END) AS g
			              FROM quickask_logs AS logs
			              JOIN quickask_log_matchingtemplates_links AS matchingtemplates_links ON logs.quickask_log_id = matchingtemplates_links.parent_quickask_log_id
			              JOIN quickask_matchingtemplates AS matchingtemplates ON matchingtemplates_links.child_quickask_matchingtemplate_id = matchingtemplates.quickask_matchingtemplate_id
			              JOIN quickask_questions AS questions ON matchingtemplates.question = questions.quickask_question_id
			              WHERE logs.searchtype = 1
			              AND logs.timestampwhen >= ${timeframe.start}
			              AND logs.timestampwhen <= ${timeframe.end}
			              AND logs.textEngine IN (${.textEngines.join(',')})
			              GROUP BY x, g
			              ORDER BY x";
			.setGroups(['Close Answer' => I('Close Answer'), 'Related Answer' => I('Related Answer')]);
			return ObjRunObject.rawQuery(sql);
		}
	}
}
/**
 * @end
 */

