uses 'console';
uses 'statistic';
uses 'ObjRunSrv';
uses 'objrunsrv-workflow';

/**
 * @namespace Reports
 * @brief Contains all Cention Reports
 */
namespace Reports {
	/**
	 * @class IncomingErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for incoming errands statistic view
	 */
	class IncomingErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Incoming');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( object timeframe )
		 * @brief Fetches data used by the getData() function
		 * @param object timeframe The timeframe in which to fetch values
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				array email = Workflow.Errand.incomingReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents, .outputTime.format() );
				.addDataGroup( I('Email'), email );
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				array manual = Workflow.Errand.incomingReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents, .outputTime.format() );
				.addDataGroup( I('Manual'), manual );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ClosedErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for closed errands statistic view
	 */
	class ClosedErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Closed');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				array email = Workflow.Errand.closedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents, .outputTime.format() );
				.addDataGroup(I('Email'), email );
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				array manual = Workflow.Errand.closedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents, .outputTime.format() );
				.addDataGroup( I('Manual'), manual );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class PublishedErrands
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for published errands statistic view
	 */
	class PublishedErrands extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Published');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				array email = Workflow.Errand.publishedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents, .outputTime.format() );
				.addDataGroup( I('Email'), email );
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				array manual = Workflow.Errand.publishedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents, .outputTime.format() );
				.addDataGroup( I('Manual'), manual );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ClosedErrandsWithReplies
	 * @extends Statistic.AbsoluteTimeView
	 * @brief Handles data needed for closed errands with replies statistic view
	 */
	// Replies
	class ClosedErrandsWithReplies extends Statistic.AbsoluteTimeView {
		string name;
		
		constructor {
			super();
			.name = I('Replies');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				array email = Workflow.Errand.repliesReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents, .outputTime.format() );
				.addDataGroup( I('Email'), email );
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				array manual = Workflow.Errand.repliesReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents, .outputTime.format() );
				.addDataGroup( I('Manual'), manual );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandClosureStatus
	 * @extends Statistic.AgentView
	 * @brief Handles data needed for errand closure status statistic view
	 */
	class ErrandClosureStatus extends Statistic.AgentView {
		string name;
		
		constructor {
			super();
			.name = I('Closure status');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			array answered = [];
			array deleted = [];
			array returned = [];
			array agent = [];
			array area = [];
			array folder = [];
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				answered = Workflow.Errand.closureStatusAnsweredReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				deleted  = Workflow.Errand.closureStatusDeletedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				returned = Workflow.Errand.closureStatusReturnedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				agent    = Workflow.Errand.closureStatusForwardedToAgentReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				area     = Workflow.Errand.closureStatusForwardedToAreaReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				if( F('folders') ) {
					folder   = Workflow.Errand.closureStatusForwardedToFolderReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				}
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				Workflow.Errand.closureStatusAnsweredReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
					if( not answered.keyExists(key) )
						answered[key] = 0;
					answered[key] += value;
				};
				Workflow.Errand.closureStatusDeletedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
					if( not deleted.keyExists(key) )
						deleted[key] = 0;
					deleted[key] += value;
				};
				Workflow.Errand.closureStatusReturnedReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
					if( not returned.keyExists(key) )
						returned[key] = 0;
					returned[key] += value;
				};
				Workflow.Errand.closureStatusForwardedToAgentReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
					if( not agent.keyExists(key) )
						agent[key] = 0;
					agent[key] += value;
				};
				Workflow.Errand.closureStatusForwardedToAreaReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
					if( not area.keyExists(key) )
						area[key] = 0;
					area[key] += value;
				};
				if( F('folders') ) {
					Workflow.Errand.closureStatusForwardedToFolderReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ).map() using ( key, value ) {
						if( not folder.keyExists(key) )
							folder[key] = 0;
						folder[key] += value;
					};
				}
			}
			answered.keys().each() using ( key ) {
				if( not deleted.keyExists(key) )
					deleted[key] = 0;
				if( not returned.keyExists(key) )
					returned[key] = 0;
				if( not area.keyExists(key) )
					area[key] = 0;
				if( not agent.keyExists(key) )
					agent[key] = 0;
				if( not folder.keyExists(key) )
					folder[key] = 0;
			};
			deleted.keys().each() using ( key ) {
				if( not answered.keyExists(key) )
					answered[key] = 0;
				if( not returned.keyExists(key) )
					returned[key] = 0;
				if( not area.keyExists(key) )
					area[key] = 0;
				if( not agent.keyExists(key) )
					agent[key] = 0;
				if( not folder.keyExists(key) )
					folder[key] = 0;
			};
			returned.keys().each() using ( key ) {
				if( not answered.keyExists(key) )
					deleted[key] = 0;
				if( not deleted.keyExists(key) )
					deleted[key] = 0;
				if( not area.keyExists(key) )
					area[key] = 0;
				if( not agent.keyExists(key) )
					agent[key] = 0;
				if( not folder.keyExists(key) )
					folder[key] = 0;
			};
			area.keys().each() using ( key ) {
				if( not answered.keyExists(key) )
					deleted[key] = 0;
				if( not deleted.keyExists(key) )
					deleted[key] = 0;
				if( not returned.keyExists(key) )
					returned[key] = 0;
				if( not agent.keyExists(key) )
					agent[key] = 0;
				if( not folder.keyExists(key) )
					folder[key] = 0;
			};
			agent.keys().each() using ( key ) {
				if( not answered.keyExists(key) )
					deleted[key] = 0;
				if( not deleted.keyExists(key) )
					deleted[key] = 0;
				if( not returned.keyExists(key) )
					returned[key] = 0;
				if( not area.keyExists(key) )
					area[key] = 0;
				if( not folder.keyExists(key) )
					folder[key] = 0;
			};
			if( F('folders') ) {
				folder.keys().each() using ( key ) {
					if( not answered.keyExists(key) )
						deleted[key] = 0;
					if( not deleted.keyExists(key) )
						deleted[key] = 0;
					if( not returned.keyExists(key) )
						returned[key] = 0;
					if( not area.keyExists(key) )
						area[key] = 0;
					if( not agent.keyExists(key) )
						agent[key] = 0;
				};
			}
			.addDataGroup( I('Answered'), answered );
			.addDataGroup( I('Deleted'), deleted );
			.addDataGroup( I('Returned'), returned );
			.addDataGroup( I('Forwarded to agent'), agent );
			.addDataGroup( I('Forwarded to area'), area );
			if( F('folders') ) {
				.addDataGroup( I('Moved to folder'), folder );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandResponseTime
	 * @extends Statistic.RelativeTimeView
	 * @brief Handles data needed for response time statistic view
	 */
	class ErrandResponseTime extends Statistic.RelativeTimeView {
		string name;
		string key;
		
		constructor {
			super();
			.name = I('Response time');
			.key = I('Response time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				array email = Workflow.Errand.responseTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				.addDataGroup( I('Email'), email );
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				array manual = Workflow.Errand.responseTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents );
				.addDataGroup( I('Manual'), manual );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ErrandProcessTime
	 * @extends Statistic.RelativeTimeView
	 * @brief Handles data needed for errand process time statistic view
	 */
	class ErrandProcessTime extends Statistic.RelativeTimeView {
		constructor {
			super();
			.name = I('Process time');
			.key = I('Process time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				array email = Workflow.Errand.processTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				.addDataGroup( I('Email'), email );
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				array manual = Workflow.Errand.processTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents );
				.addDataGroup( I('Manual'), manual );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AverageErrandResponseTime
	 * @extendsStatistic.AreaRelativeTimeView
	 * @brief Handles data needed for average errand response time statistic view
	 */
	class AverageErrandResponseTime extends Statistic.AreaRelativeTimeView {
		string name = "Average response time";
		
		constructor {
			super();
			.name = I('Average response time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				array email = Workflow.Errand.averageResponseTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				.addDataGroup( I('Email'), email );
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				array manual = Workflow.Errand.averageResponseTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents );
				.addDataGroup( I('Manual'), manual );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AverageErrandProcessTime
	 * @extends Statistic.AgentRelativeTimeView
	 * @brief Handles data needed for average errand process time statistic view
	 */
	class AverageErrandProcessTime extends Statistic.AgentRelativeTimeView {
		string name = "Average process time";
		
		constructor {
			super();
			.name = I('Average process time');
		}
		
		/**
		 * @function fetchData
		 * @declaration function fetchData( number timeframeStart, number timeframeEnd )
		 * @brief Fetches data used by the getData() function
		 * @param number timeframeStart the start timestamp for the timeframe
		 * @param number timeframeEnd the end timestamp for the timeframe
		 * @returns An array with the data
		 */
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL ) {
				array email = Workflow.Errand.averageProcessTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents );
				.addDataGroup( I('Email'), email );
			}
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL ) {
				array manual = Workflow.Errand.averageProcessTimeReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents );
				.addDataGroup( I('Manual'), manual );
			}
		}
	}
	/**
	 * @end
	 */
	
	class ErrandClassification extends Statistic.ActionView {
		string name;
		
		constructor {
			super();
			.name = I('Classification');
			.key = I('Classification');
		}
		
		function parseValues( array& values ) {
			array newValues = [];
			object r = new Regexp( 'client\.\[(.*)\]' );
			values.map() using ( key, value ) {
				if( not key.nCompareCase( 'system.', 7 ) ) {
					key = r.replaceAll( key ) using ( match ) {
						array captures = match.captures();
						return captures[0];
					};
					newValues[key] = value;
				}
			};
			return newValues;
		}
				
		function fetchData( object timeframe ) {
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_EMAIL )
				.addDataGroup( I('Email'), .parseValues( Workflow.Errand.classificationReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_EMAIL, .areas, .byAgent, .agents ) ) );
			if( .service == Statistic.SERVICE_ALL or .service == Statistic.SERVICE_MANUAL )
				.addDataGroup( I('Manual'), .parseValues( Workflow.Errand.classificationReport( timeframe.start, timeframe.end, Workflow.Errand.SERVICE_MANUAL, .areas, .byAgent, .agents ) ) );
		}
	}
}
/**
 * @end
 */

