uses 'console';
uses 'date';
uses 'reflection';

/**
 * @namespace Statistic
 * @brief Contains classes for working with statistics especially the Cention Reports system
 */
namespace Statistic {
	
	final number SERVICE_ALL = 0;
	final number SERVICE_EMAIL = 1;
	final number SERVICE_MANUAL = 2;
	
	/**
	 * @class Timeframe
	 * @brief A timeframe with a start time and and an end time
	 */
	class Timeframe {
		/**
		 * @variable start
		 * @type number
		 * @brief The timestamp representing the start of the timeframe
		 */
		number start;
		
		/**
		 * @variable end
		 * @type number
		 * @brief The timestamp object representing the end of the timeframe
		 */
		number end;
		
		/**
		 * @function constructor
		 * @declaration function constructor( number start, number end )
		 * @brief Creates a new Timeframe object with a timestamp as start and a timestamp as end
		 * @param number start unix timestamp that should be the start of the timeframe
		 * @param number end unix timestamp that should be the end of the timeframe
		 */
		function constructor( number start, number end ) {
			.start = start;
			.end = end;
		}
		
		/**
		 * @function constructor
		 * @declaration function constructor( string start, string end )
		 * @brief Creates a new Timeframe object with a string as start and a string as end
		 * @param string start string looking like YEAR-MONTH-DAY
		 * @param string end string looking like YEAR-MONTH-DAY
		 */
		function constructor( string start, string end ) {
			.start = Date.parse( start, "%F %T" ).time();
			.end = Date.parse( end, "%F %T" ).time();
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class Time
	 * @brief Base class for all relative times
	 */
	class Time {
		string name;
		number seconds;
		
		function constructor( string name, number seconds ) {
			.name = name;
			.seconds = seconds;
		}
		
		/**
		 * @function length
		 * @declaration function length( number seconds )
		 * @brief Calculate how many this Time happened during seconds
		 * @param number seconds the number of seconds
		 * @return The number of this Time that are elapsed during the seconds
		 */
		function length( number seconds ) {
			return ( seconds / .seconds );
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class view
	 * @brief The base class for all statistic views
	 */
	abstract class View {
		object timeframe;
		array dataGroups;
		array groups;
		array areas;
		array agents;
		number service;
		number systemGroup;
		string language;
		
		function setLanguage( string language )
			.language = language;
		
		function setSystemGroup( number systemGroup )
			.systemGroup = systemGroup;
		
		function setService( number service )
			.service = service;
		
		function serviceWhereClause {
			if( .service == Workflow.Errand.SERVICE_EMAIL ) {
				return "AND data.service_id IN (0, 1)";
			} else if( .service != Workflow.Errand.SERVICE_ANY ) {
				return "AND data.service_id = ${.service}";
			}
			return "";
		}
		
		function setTimeframe( object timeframe )
			.timeframe = timeframe;
		
		function setTimeframe( number start, number end )
			.timeframe = new Statistic.Timeframe( start, end );
		
		function setGroups( array groups ) {
			.groups = groups;
		}
		
		function setAreas( array areas ) {
			.areas = areas;
		}
		
		function setAgents( array agents ) {
			.agents = agents;
		}
		
		function isTimeView
			return false;
		
		function makeData( string keyHeaderName, array rawData ) {
			number rawRowCount = rawData.size();
			array columnHeaders = [];
			array rows = [];
		
			// +---------+-------+--------+
			// | Time    | Email | Manual |
			// +---------+-------+--------+
			// | January | 234   | 23     |
			// +---------+-------+--------+
			// | October | 345   | 41     |
			// +---------+-------+--------+
		
			// [ 'x' => 'January', 'y' => 234, 'group' => 'Email' ]
			// [ 'x' => 'January', 'y' => 23', 'group' => 'Manual' ];
		
			// [ 'January', 234, 23 ]
			// [ 'October', 235, 41 ]

			columnHeaders[] = keyHeaderName;
			
			.groups.each() using ( column ) {
				columnHeaders[] = column;
			};
			
			for( number i = 0; i < rawRowCount; i++ ) {
				array rawRow = rawData[i]; // Should this be avoided in this case?
				array row = [];
				string translation = I(rawRow['g']);
				
				if( not (.groups.keyExists(rawRow['g'])) ) {
					.groups[rawRow['g']] = translation;
					columnHeaders[] = translation;
				}
				
				if( not rows.keyExists('' + rawRow['x']) ) {
					row = [ '' + rawRow['x'], 0, 0, 0, 0, 0, 0 ];
				} else {
					row = rows['' + rawRow['x']];
				}
				
				row[.groups.getIndex(rawRow['g'])+1] = rawRow['y'];
				
				rows['' + rawRow['x']] = row;
			}
			
			return [ 'ColumnHeaders' => columnHeaders, 'Rows' => rows ];
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class TimeView
	 * @extends Statistic.View
	 * @brief Base class for a statistic options dealing with time
	 */
	abstract class TimeView extends View {
		object outputTime;
		
		function setOutputTime( object outputTime )
			.outputTime = outputTime;
		
		function isTimeView
			return true;
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AbsoluteTimeView
	 * @extends Statistic.TimeView
	 * @brief Displays values based on at what time a timestamp occurred
	 */
	abstract class AbsoluteTimeView extends TimeView {
		function isAbsoluteTimeView
			return true;
		
		function translate( string text, string language ) {
			array list = [];
			if( language == 'sv' ) {
				list = [ [ 'January'   => 'Januari',
				         'February'  => 'Februari',
				         'March'     => 'Mars',
				         'April'     => 'April',
				         'May'       => 'Maj',
				         'June'      => 'Juni',
				         'July'      => 'Juli',
				         'August'    => 'Augusti',
				         'September' => 'September',
				         'October'   => 'Oktober',
				         'November'  => 'November',
				         'December'  => 'December',
				         'Monday'    => 'Måndag',
				         'Tuesday'   => 'Tisdag',
				         'Wednesday' => 'Onsdag',
				         'Thursday'  => 'Torsdag',
				         'Friday'    => 'Fredag',
				         'Saturday'  => 'Lördag',
				         'Sunday'    => 'Söndag' ],
				         [ 'Oct'       => 'Okt',
				         'Mon'       => 'Mån',
				         'Tue'       => 'Tis',
				         'Wed'       => 'Ons',
				         'Thu'       => 'Tor',
				         'Fri'       => 'Fre',
				         'Sat'       => 'Lör',
				         'Sun'       => 'Sön' ] ];
			}
			list.each() using ( translations ) {
				translations.map() using ( key, value ) {
					text = text.replace( key, value );
				};
			};
			return text;
		}
		
		/**
		 * @function getData
		 * @declaration function getData()
		 * @brief Get the data parsed, sorted and ready to be used
		 * @return An array with the data
		 */
		function getData() {
			array data = [];
			if( .timeframe and .outputTime ) {
				data = .makeData( I(.outputTime.name), .fetchData( .timeframe ) );
				if( .language != 'en' ) {
					if( data.keyExists('Rows') ) {
						for( number i = 0; i < data['Rows'].size(); i++ ) {
							data['Rows'][i][0] = .translate( data['Rows'][i][0], .language );
						};
					}
				}
			}
			return data;
		}
		array orderingFieldsList;
		function extractFunctionCalls( string timestamp ) {
			string functionCalls;
			number fieldNumber = 1;
			array items = .outputTime.items;
			array fields = [];
			.orderingFieldsList = [];
			items.each() using ( item ) {
				switch(item.pgsqlFormat) {
					case 'Dy':
					case 'Day':
						fields[] = 'dow';
						break;
					case 'Mon':
					case 'Month':
					case 'MM':
						fields[] = 'month';
						break;
					case 'DD':
					case 'D':
						fields[] = 'day';
						break;
					case 'IYYY-MM-DD':
						fields[] = 'year';
						fields[] = 'month';
						fields[] = 'day';
						break;
					case 'HH24':
						fields[] = 'hour';
						break;
					case 'MI':
						fields[] = 'minute';
						break;
					case 'HH24:MI':
						fields[] = 'hour';
						fields[] = 'minute';
						break;
					case 'HH24:MI:SS':
						fields[] = 'hour';
						fields[] = 'minute';
						fields[] = 'second';
						break;
					case 'SS':
						fields[] = 'second';
						break;
					case 'IW':
						fields[] = 'week';
						break;
					case 'IYYY':
						fields[] = 'year';
						break;
				}
			};
			fields.eachWithIndex() using ( field, index ) {
				functionCalls += "extract(${field} from (TIMESTAMP 'epoch' + ${timestamp} * INTERVAL '1  second')) AS ordering${index},";
				.orderingFieldsList[] = "ordering${index}";
			};
			return functionCalls;
		}
		
		function orderingFields() {
			return ( .orderingFieldsList ? ',' : '' ) + .orderingFieldsList.join(',') + ',';
		}
		
		function orderByStatement {
			return ( .orderingFieldsList ? 'ORDER BY ' + .orderingFieldsList.join(',') : '' );
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class RelativeTimeView
	 * @extends Statistic.TimeView
	 * brief Displays values based on how long time a timestamp represents
	 */
	abstract class RelativeTimeView extends TimeView {
		string key;
		
		function isAbsoluteTimeView
			return false;
		
		/**
		 * @function getData
		 * @declaration function getData()
		 * @brief Get the data parsed, sorted and ready to be used
		 * @return An array with the data
		 */
		function getData() {
			array data = [];
			if( .timeframe and .outputTime ) {
				data = .makeData( .key, .fetchData( .timeframe ) );
			}
			return data;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ActionView
	 * @extends Statistic.View
	 * @brief Displays how many times a list of actions occurred
	 */
	abstract class ActionView extends View {
		string key;
		/**
		 * @function getData
		 * @declaration function getData()
		 * @brief Get the data parsed, sorted and ready to be used
		 * @return An array with the data
		 */
		function getData() {
			array data = [];
			if( .timeframe ) {
				data = .makeData( .key, .fetchData( .timeframe ) );
			}
			return data;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AreaView
	 * @extends Statistic.View
	 */
	abstract class AreaView extends View {
		string key;
		
		constructor {
			super();
			.key = I('Area');
		}
		
		function getData() {
			array data = [];
			if( .timeframe ) {
				data = .makeData( .key, .fetchData( .timeframe ) );
			}
			return data;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AreaTimeView
	 * @extends Statistic.TimeView
	 */
	abstract class AreaRelativeTimeView extends RelativeTimeView {
		constructor {
			super();
			.key = I('Area');
		}
		
		/*
		function getData() {
			array data = [];
			
			if( .timeframe ) {
				array newDataGroups = [];
				
				.fetchData( .timeframe );
				
				.dataGroups.each() using ( dataGroup ) {
					object newDataGroup = new Statistic.DataGroup();
					newDataGroup.name = dataGroup.name;
					newDataGroup.values = [];
					
					dataGroup.values.map() using ( key, value ) {
						value = .outputTime.length( value );
						if( not newDataGroup.values.keyExists( key ) )
							newDataGroup.values[key] = 0;
						newDataGroup.values[key] += value;
					};
					
					newDataGroups[] = newDataGroup;
				};
				
				.dataGroups = newDataGroups;
				
				data = .makeData( .key );
				
				
				data['Rows'] = data['Rows'].sort() using ( a, b ) {
					number aTime = a[0].toNumber();
					number bTime = b[0].toNumber();
					if( aTime < bTime ) return -1;
					if( aTime == bTime ) return 0;
					if( aTime > bTime ) return 1;
				};
			}
			
			return data;
		}
		*/
	}
	
	/**
	 * @class AgentView
	 * @extends Statistic.View
	 * @brief Displays values divided into list of agents
	 */
	abstract class AgentView extends AreaView {
		constructor {
			super();
			.key = I('Agent');
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AgentTimeView
	 * @extends Statistic.AreaTimeView
	 */
	abstract class AgentRelativeTimeView extends AreaRelativeTimeView {
		constructor {
			super();
			.key = I('Agent');
		}
	}
	/**
	 * @end
	 */
}
/**
 * @end
 */

