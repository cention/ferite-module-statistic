uses 'console';
uses 'date';
uses 'reflection';

/**
 * @namespace Statistic
 * @brief Contains classes for working with statistics especially the Cention Reports system
 */
namespace Statistic {
	/**
	 * @class Timeframe
	 * @brief A timeframe with a start time and and an end time
	 */
	class Timeframe {
		/**
		 * @variable start
		 * @type object
		 * @brief The Date object representing the start of the time frame
		 */
		object start;
		
		/**
		 * @variable end
		 * @type object
		 * @brief The Date object representing the end of the timeframe
		 */
		object end;
		
		/**
		 * @function constructor
		 * @declaration function constructor( object start, object end )
		 * @brief Creates a new Timeframe object with a Date object as start and a Date object as end
		 * @param object start Date object that should be the start of the timeframe
		 * @param object end Date object that should be the end of the timeframe
		 */
		function constructor( object start, object end ) {
			.start = start;
			.end = end;
		}
		
		/**
		 * @function constructor
		 * @declaration function constructor( number start, number end )
		 * @brief Creates a new Timeframe object with a timestamp as start and a timestamp as end
		 * @param number start unix timestamp that should be the start of the timeframe
		 * @param number end unix timestamp that should be the end of the timeframe
		 */
		function constructor( number start, number end ) {
			.start = Date.date( start );
			.end = Date.date( end );
		}
		
		/**
		 * @function constructor
		 * @declaration function constructor( string start, string end )
		 * @brief Creates a new Timeframe object with a string as start and a string as end
		 * @param string start string looking like YEAR-MONTH-DAY
		 * @param string end string looking like YEAR-MONTH-DAY
		 */
		function constructor( string start, string end ) {
			.start = Date.parse( start, "%F" );
			.end = Date.parse( end, "%F" );
		}
	}
	/**
	 * @end
	 */
	
	abstract class TimeFormat {
		object nextTimeFormat;
		
		function constructor( object nextTimeFormat )
			.nextTimeFormat = nextTimeFormat;
		
		function whenIsThis( number timestamp ) {
			object date = Date.date( timestamp );
			string text = date.format( .format );
			
			if( .nextTimeFormat )
				text += " " + .nextTimeFormat.whenIsThis( timestamp );
			
			return text;
		}
		
		function howLongIsThis( number seconds ) {
			return seconds / .seconds;
		}
	}
	
	class YearTimeFormat extends TimeFormat {
		string format = "%Y";
		number seconds = 31536000;
	}
	
	class MonthTimeFormat extends TimeFormat {
		string format = "%B";
		number seconds = 2592000;
	}
	
	class WeekTimeFormat extends TimeFormat {
		string format = "%V";
		number seconds = 604800;
	}
	
	class WeekdayTimeFormat extends TimeFormat {
		string format = "%A";
		number seconds = 86400;
	}
	
	class DayTimeFormat extends TimeFormat {
		string format = "%F";
		number seconds = 86400;
	}
	
	class HourTimeFormat extends TimeFormat {
		string format = "%H";
		number seconds = 3600;
	}
	
	class MinuteTimeFormat extends TimeFormat {
		string format = "%M";
		number seconds = 60;
	}
	
	class SecondTimeFormat extends TimeFormat {
		string format = "%S";
		number seconds = 1;
	}
	
	/**
	 * @class view
	 * @brief The base class for all statistic views
	 */
	abstract class View {
		array timeframes;
		
		/**
		 * @function addTimeframe
		 * @declaration function addTimeframe( object timeframe )
		 * @brief Add a timeframe from a Timeframe object in which values should be fetched
		 * @param object timeframe a Statistic.Timeframe object
		 */
		function addTimeframe( object timeframe )
			.timeframes[] = timeframe;
		
		/**
		 * @function addTimeframe
		 * @declaration function addTimeframe( number start, number end )
		 * @brief Add a timeframe from timestamps in which values should be fetched
		 * @param number start a unix timestamp
		 * @param number end a unix timestamp
		 */
		function addTimeframe( number start, number end )
			.timeframes[] = new Statistic.Timeframe( start, end );
		
		/**
		 * @function addTimeframe
		 * @declaration function addTimeframe( object start, object end )
		 * @brief Add a timeframe from Date objects in which values should be fetched
		 * @param object start a Date object
		 * @param object end a Date object
		 */
		function addTimeframe( object start, object end )
			.timeframes[] = new Statistic.Timeframe( start, end );
	}
	/**
	 * @end
	 */
	
	/**
	 * @class TimeView
	 * @extends Statistic.View
	 * @brief Base class for a statistic options dealing with time
	 */
	abstract class TimeView extends View {
		object timeFormat;
		
		/**
		 * @function constructor
		 * @declaration function constructor()
		 * @brief Creates a new TimeView with default values
		 */
		function constructor()
			.timeFormat = new Statistic.HourTimeFormat();
		
		function setTimeFormat( object timeFormat )
			.timeFormat = timeFormat;
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AtWhatTimeView
	 * @extends Statistic.TimeView
	 * @brief Displays values based on at what time a timestamp occurred
	 */
	abstract class AtWhatTimeView extends TimeView {
		/**
		 * @function getData
		 * @declaration function getData()
		 * @brief Get the data parsed, sorted and ready to be used
		 * @return An array looking like this [ time => count ]
		 */
		function getData() {
			array rawData = [];
			array timeList = [];
			array parsedData = [];
			
			rawData = .fetchData();
			
			rawData.each() using ( value ) {
				string time = .timeFormat.whenIsThis( value );
				
				if( not timeList.keyExists( time ) )
					timeList[time] = [];
				
				timeList[time][] = value;
			};
			
			timeList.map() using ( key, value ) {
				parsedData[key] = value.size();
			};
			
			return parsedData;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class HowLongTimeView
	 * @extends Statistic.TimeView
	 * brief Displays values based on how long time a timestamp represents
	 */
	abstract class HowLongTimeView extends TimeView {
		/**
		 * @function getData
		 * @declaration function getData()
		 */
		function getData() {
			array rawData = [];
			array timeList = [];
			array parsedData = [];
			
			rawData = .fetchData();
			
			rawData = rawData.sort();
			
			rawData.each() using ( value ) {
				string time = "" + .timeFormat.howLongIsThis( value );
				
				if( not timeList.keyExists( time ) )
					timeList[time] = [];
				
				timeList[time][] = value;
			};
			
			timeList.map() using ( key, value ) {
				parsedData[key] = value.size();
			};
			
			return parsedData;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ActionView
	 * @extends View
	 * @brief Displays how many times a list of actions occurred
	 */
	abstract class ActionView extends View {
		/**
		 * @function getData
		 * @declaration function getData()
		 */
		function getData();
	}
	/**
	 * @end
	 */
	
	/**
	 * @class OperatorView
	 * @extends View
	 * @brief Displays values divided by a list of operators
	 */
	abstract class OperatorView extends View {
		/**
		 * @function getData
		 * @declaration function getData()
		 */
		function getData();
	}
	/**
	 * @end
	 */
}
/**
 * @end
 */

