uses 'console';
uses 'date';
uses 'reflection';

/**
 * @namespace Statistic
 * @brief Contains classes for working with statistics especially the Cention Reports system
 */
namespace Statistic {
	/**
	 * @class Timeframe
	 * @brief A timeframe with a start time and and an end time
	 */
	class Timeframe {
		/**
		 * @variable start
		 * @type number
		 * @brief The timestamp representing the start of the timeframe
		 */
		number start;
		
		/**
		 * @variable end
		 * @type number
		 * @brief The timestamp object representing the end of the timeframe
		 */
		number end;
		
		/**
		 * @function constructor
		 * @declaration function constructor( number start, number end )
		 * @brief Creates a new Timeframe object with a timestamp as start and a timestamp as end
		 * @param number start unix timestamp that should be the start of the timeframe
		 * @param number end unix timestamp that should be the end of the timeframe
		 */
		function constructor( number start, number end ) {
			.start = start;
			.end = end;
		}
		
		/**
		 * @function constructor
		 * @declaration function constructor( string start, string end )
		 * @brief Creates a new Timeframe object with a string as start and a string as end
		 * @param string start string looking like YEAR-MONTH-DAY
		 * @param string end string looking like YEAR-MONTH-DAY
		 */
		function constructor( string start, string end ) {
			.start = Date.parse( start, "%F %T" ).time();
			.end = Date.parse( end, "%F %T" ).time();
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class Time
	 * @brief Base class for all relative times
	 */
	class Time {
		string name;
		number seconds;
		
		function constructor( string name, number seconds ) {
			.name = name;
			.seconds = seconds;
		}
		
		/**
		 * @function length
		 * @declaration function length( number seconds )
		 * @brief Calculate how many this Time happened during seconds
		 * @param number seconds the number of seconds
		 * @return The number of this Time that are elapsed during the seconds
		 */
		function length( number seconds ) {
			return ( seconds / .seconds );
		}
	}
	/**
	 * @end
	 */
	
	class DataGroup {
		string name;
		array values;
		constructor( string name, array values ) {
			.name = name;
			.values = values;
		}
		function toString {
			return '' + .values;
		}
	}
	
	final static number SERVICE_ALL = 0;
	final static number SERVICE_EMAIL = 1;
	final static number SERVICE_MANUAL = 2;
	
	/**
	 * @class view
	 * @brief The base class for all statistic views
	 */
	abstract class View {
		object timeframe;
		array dataGroups;
		boolean byArea;
		array areas;
		boolean byAgent;
		array agents;
		number service;		
		
		function setService( number service )
			.service = service;
		
		function setTimeframe( object timeframe )
			.timeframe = timeframe;
		
		function setTimeframe( number start, number end )
			.timeframe = new Statistic.Timeframe( start, end );
		
		function addDataGroup( string name, array data )
			.dataGroups[] = new Statistic.DataGroup( name, data );
		
		function addArea( number id ) {
			.byArea = true;
			.areas[] = name;
		}
		
		function setAreas( array areas ) {
			if( areas.size() > 0 ) {
				.byArea = true;
				.areas = areas;
			}
		}
		
		function addAgent( number id ) {
			.byAgent = true;
			.agents[] = id;
		}
		
		function setAgents( array agents ) {
			if( agents.size() > 0 ) {
				.byAgent = true;
				.agents = agents;
			}
		}
		
		function isTimeView
			return false;
		
		function makeData( string keyHeaderName ) {
			array columnHeaders = [];
			array valueColumns = [];
			array rows = [];
			
			// Add the header for the first column (the key column e.g. the time
			// in a time view or the agent's name in an agent view
			columnHeaders[] = keyHeaderName;
			
			// Go through all data groups (e.g. Email and Manual) and create column headers
			.dataGroups.each() using ( dataGroup ) {
				// If the value is an array that means we have multiple
				// values for a key (e.g. closure statuses for an agent).
				if( dataGroup.values.size() > 0 and dataGroup.values[0] isa array ) {
					dataGroup.values.each() using ( value ) {
						value.map() using ( key, v ) {
							// Data from object server might look like this:
							// [ 'agent1' => [ 'status1' => 1, 'status3' => 2 ],
							//   'agent2' => [ 'status2' => 1 ] ]
							// That means we have to go through all the data
							// and fetch all key names (which will be column headers)
							// so when putting the data into rows later we can
							// do like this for e.g. agent one: 'status2' => 0
							// and everything will be good in the world
							if( not columnHeaders.keyExists( key ) ) {
								columnHeaders[] = key;
								valueColumns[] = key;
							}
						};
					};
				} else {
					// If only one value exists the data group name is used
					// as column header (e.g. Email and Manual)
					columnHeaders[] = dataGroup.name;
					// The valueColumns array will not be used in the single value case
					valueColumns[] = dataGroup.name;
				}
			};
			
			// Go through all data groups and create rows
			.dataGroups.each() using ( dataGroup ) {
				dataGroup.values.map() using ( key, value ) {
					boolean rowExists = false;
					number rowIndex = -1;
					array row = [];
					rows.eachWithIndex() using ( r, i ) {
						if( r[0] == key ) {
							row = r;
							rowExists = true;
							rowIndex = i;
						}
					};
					if( not rowExists ) {
						// If the first column is 'Agent' this would be the agent's name
						row[] = key;
					}
					// Multiple values for a key (e.g closure status)
					if( value isa array ) {
						// We need to go through and make sure that we have values
						// in all columns in all rows. See above why.
						valueColumns.each() using ( column ) {
							boolean columnFound = false;
							value.map() using ( k, v ) {
								if( k == column ) {
									row[] = v;
									columnFound = true;
									return false; // break;
								};
							};
							if( not columnFound ) {
								row[] = 0;
							}
						};
					} else {
						row[] = value;
					}
					if( rowIndex > -1 ) {
						rows[rowIndex] = row;
					} else {
						rows[] = row;
					}
				};
			};
			
			return [ 'ColumnHeaders' => columnHeaders, 'Rows' => rows ];
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class TimeView
	 * @extends Statistic.View
	 * @brief Base class for a statistic options dealing with time
	 */
	abstract class TimeView extends View {
		object outputTime;
		
		function setOutputTime( object outputTime )
			.outputTime = outputTime;
		
		function isTimeView
			return true;
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AbsoluteTimeView
	 * @extends Statistic.TimeView
	 * @brief Displays values based on at what time a timestamp occurred
	 */
	abstract class AbsoluteTimeView extends TimeView {
		function isAbsoluteTimeView
			return true;
		
		/**
		 * @function getData
		 * @declaration function getData()
		 * @brief Get the data parsed, sorted and ready to be used
		 * @return An array with the data
		 */
		function getData() {
			array data = [];
			if( .timeframe and .outputTime ) {
				.fetchData( .timeframe );
				data = .makeData( .outputTime.name );
				data['Rows'] = data['Rows'].sort() using ( a, b ) {
					number aTimestamp = .outputTime.toTimestamp( a[0] );
					number bTimestamp = .outputTime.toTimestamp( b[0] );
					if( aTimestamp < bTimestamp ) return -1;
					if( aTimestamp == bTimestamp ) return 0;
					if( aTimestamp > bTimestamp ) return 1;
				};
			}
			return data;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class RelativeTimeView
	 * @extends Statistic.TimeView
	 * brief Displays values based on how long time a timestamp represents
	 */
	abstract class RelativeTimeView extends TimeView {
		function isAbsoluteTimeView
			return false;
		
		/**
		 * @function getData
		 * @declaration function getData()
		 * @brief Get the data parsed, sorted and ready to be used
		 * @return An array with the data
		 */
		function getData() {
			array data = [];
			
			if( .timeframe ) {
				array newDataGroups = [];
				
				.fetchData( .timeframe );
				
				.dataGroups.each() using ( dataGroup ) {
					object newDataGroup = new Statistic.DataGroup();
					newDataGroup.name = dataGroup.name;
					newDataGroup.values =Â [];
					
					dataGroup.values.map() using ( key, value ) {
						key = '' + .outputTime.length( key.toNumber() );
						if( not newDataGroup.values.keyExists( key ) )
							newDataGroup.values[key] = 0;
						newDataGroup.values[key] += value;
					};
					
					newDataGroups[] = newDataGroup;
				};
				
				.dataGroups = newDataGroups;
				
				data = .makeData( .key );
				
				
				data['Rows'] = data['Rows'].sort() using ( a, b ) {
					number aTime = a[0].toNumber();
					number bTime = b[0].toNumber();
					if( aTime < bTime ) return -1;
					if( aTime == bTime ) return 0;
					if( aTime > bTime ) return 1;
				};
			}
			
			return data;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ActionView
	 * @extends Statistic.View
	 * @brief Displays how many times a list of actions occurred
	 */
	abstract class ActionView extends View {
		/**
		 * @function getData
		 * @declaration function getData()
		 * @brief Get the data parsed, sorted and ready to be used
		 * @return An array with the data
		 */
		function getData() {
			array data = [];
			if( .timeframe ) {
				.fetchData( .timeframe );
				data = .makeData( .key );
			}
			return data;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AreaView
	 * @extends Statistic.View
	 */
	abstract class AreaView extends View {
		string key = "Area";
		
		function getData() {
			array data = [];
			if( .timeframe ) {
				.fetchData( .timeframe );
				data = .makeData( .key );
			}		
			return data;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AreaTimeView
	 * @extends Statistic.TimeView
	 */
	abstract class AreaRelativeTimeView extends RelativeTimeView {
		string key = "Area";
	}
	
	/**
	 * @class AgentView
	 * @extends Statistic.View
	 * @brief Displays values divided into list of agents
	 */
	abstract class AgentView extends AreaView {
		string key = "Agent";
		
		function getData() {
			array data = [];
			if( .timeframe ) {
				.fetchData( .timeframe );
				data = .makeData( .key );
			}		
			return data;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AgentTimeView
	 * @extends Statistic.AreaTimeView
	 */
	abstract class AgentRelativeTimeView extends AreaRelativeTimeView {
		string key = "Agent";
	}
	/**
	 * @end
	 */
}
/**
 * @end
 */

