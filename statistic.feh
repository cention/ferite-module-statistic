uses '/cention/etc/webframework-config.feh';
uses 'webframework/Core/Database';
uses 'array';
uses 'console';
uses 'date';

namespace modifies Array {
	function appendWithNames( array a, array b ) {
		number size = b.size();
		for( number i = 0; i < size; ++i )
			a[b.getName(i)] = b[i];
		return a;
	}
	function setRow( array& a, array& groups, string key, number value, array& extra ) {
		number size = a.size();
		number sizeGroups = groups.size();
		boolean set = false;

		//Console.printlnErr('[DEBUG) SetRow');

		for( number i = 0; i < size; ++i ) {
			boolean found = true;
			//Console.printlnErr('[DEBUG] - Row: ' + i);
			//Console.printlnErr('[DEBUG]  - Data: ' + a[i]);
			for( number j = 0; j < sizeGroups; ++j ) {
				string name;
				//Console.printlnErr('[DEBUG]  - Group: ' + j);
				name = groups.getName(j);
				//Console.printlnErr('[DEBUG]  - Group Name: ' + name);
				if( name.index('group') == 0 ) {
					//Console.printlnErr('[DEBUG]  - Array Value: "' + a[i][name] + "'");
					//Console.printlnErr('[DEBUG]  - Group Value: "' + groups[j] + "'");
					if( a[i][name] != groups[j].trim(' ') ) {
						found = false;
						break;
					}
				}
			}
			if( found ) {
				//Console.printlnErr('[DEBUG]  - Found!');
				a[i][key] = value;
				extra.each() using ( name ) {
					a[i][name] = groups[name];
				};
				set = true;
				break;
			}
		}

		if( not set ) {
			array row = [];
			for( number j = 0; j < sizeGroups; ++j ) {
				string name = groups.getName(j);
				if( name.index('group') == 0 )
					row[name] = groups[j];
			}
			row[key] = value;
			extra.each() using ( name ) {
				row[name] = groups[name];
			};
			a[] = row;
		}
	}
}

class modifies Date {
	static function currentTime() {
		number localNow = Date.now();
		object localDate = Date.localDate(localNow);
		return localDate.format("%H:%M");
	}
	static function currentHour() {
		number localNow = Date.now();
		object localDate = Date.localDate(localNow);
		return localDate.format("%H").preTrim("0").toNumber();
	}
	static function currentMinute() {
		number localNow = Date.now();
		object localDate = Date.localDate(localNow);
		return localDate.format("%M").preTrim("0").toNumber();
	}
	static function currentWeekday() {
		number localNow = Date.now();
		object localDate = Date.localDate(localNow);
		string currentWeekday = localDate.format("%A");
		return currentWeekday.toLower();
	}
	static function isBeginningOfMonth() {
		number localNow = Date.now();
		object localDate = Date.date(localNow);
		string currentDayOfMonth = localDate.format("%d");
		if( currentDayOfMonth == "01" )
			return true;
		return false;
	}
}

namespace Statistics {
	protocol KeyFigure {
		function identifier();
		function name();
		function select();
		function from();
		function where();
		function columnOrganisation();
		function columnArea();
		function columnUser();
		function columnChannel();
		function columnTime();
	}
	
	protocol Group {
		function name();
		function build();
		function select( object key );
		function from();
		function where( object key );
		function groupBy();
		function orderBy();
	}

	protocol DateTimeGroup {
		function feriteFormat();
		function format();
		function fields();
		function seconds();
		function start( string item );
		function end( string item );
	}

	abstract class AbstractKeyFigure {
		function isGroup() {
			return false;
		}
	}

	abstract class AbstractGroup {
		object _nextGroup;
		number _startTime;
		number _endTime;
		array _values;

		function values() return ._values;
		function setNextGroup( object group ) ._nextGroup = group;
		function nextGroup() return ._nextGroup;
		function setStartTime( number time ) ._startTime = time;
		function startTime() return ._startTime;
		function setEndTime( number time ) ._endTime = time;
		function endTime() return ._endTime;

		object timeFormat;
		function setTimeFormat( object format )
			.timeFormat = format;

		string groupName;
		function groupName() {
			if( not .groupName )
				.groupName = Statistics.nextGroupName();
			return .groupName;
		}

		function build( array list ) {
			array rows = [];
			string name = .groupName();
			._values = list;
			//Console.printlnErr('[DEBUG] BuildRows');
			//Console.printlnErr('[DEBUG]  - Data: ' + list);
			list.each() using ( value ) {
				if( .nextGroup() ) {
					//Console.printlnErr('[DEBUG]  - Got Next Group');
					.nextGroup().build().each() using ( row ) {
						array theRow = [ name => value ].appendWithNames(row);
						//Console.printlnErr('[DEBUG]  - Row: ' + theRow);
						rows[] = theRow;
					};
				} else {
					//Console.printlnErr('[DEBUG  - No Next Row');
					rows[] = [ name => value ];
				}
			};
			return rows;
		}

		function doInitialBuild() {
			return true;
		}
		function needTranslation() {
			return false;
		}
		function isGroup() {
			return true;
		}
	} 

	abstract class AbstractDateTimeGroup extends Statistics.AbstractGroup implements Statistics.Group {
		array _fields;
		
		function needTranslation() {
			return true;
		}
		function build() {
			if( .doInitialBuild() ) {
				array list = [];
				array have = [];
				number time = .startTime() + Date.localDate(.startTime()).tm_gmtoff;
				number endTime = .endTime() + Date.localDate(.endTime()).tm_gmtoff;
				// Tobias 2014-01-20: I don't remember why .seconds() was added to endTime here
				//                    but it produces strange results so I am going to remove it.
				while ( time <= endTime ) {
					string group = Date.localDate(time).format(.feriteFormat());
//					Console.printlnErr('(GROUP) ' + group);
					if( not have.keyExists(group) ) {
						list[] = group;
						have[group] = true;
					}
					time += .seconds();
				}
				return .build(list);
			}
			return [];
		}
		function select( object key ) {
			string columnTime = key.columnTime();
			string groupName = .groupName();
			string format = .format();
			array list = [];
			list[] = "to_char(to_timestamp(${columnTime})::timestamp at time zone 'UTC', '${format}') AS ${groupName}";
			.fields().each() using ( field ) {
				string name = Statistics.nextOrderName();
				._fields[] = name;
				list[] = "extract(${field} from (to_timestamp(${columnTime})::timestamp at time zone 'UTC')) AS ${name}";
			};
			return list.join(', ');
		}
		function from() {
			return '';
		}
		function where( object key ) {
			return '';
		}
		function groupBy() {
			array list = [];
			list[] = .groupName();
			list = list.append(._fields);
			return list.join(', ');
		}
		function orderBy() {
			return ._fields.join(', ');
		}
		function extra() {
			return [];
		}
		
		function localYearFromGMTtimestamp( number timestamp ) {
			number localDate = timestamp + Date.localDate(timestamp).tm_gmtoff;
			return Date.localDate(localDate).format('%Y');
		}
		function localDateToGMTtimestamp( string date ) {
			object d1 = Date.localParse(date, '%F %T');
			object d2 = Date.localDate(d1.time());
			if( d1.tm_isdst == 0 and d2.tm_isdst == 0 )
				return d2.time() - 3600;
			else if( d1.tm_isdst == 0 and d2.tm_isdst == 1 )
				return d2.time() - 7200 - 3600;
			else if( d1.tm_isdst == 1 and d2.tm_isdst == 1 )
				return d2.time() - 7200;
			return d2.time();
		}

		function name() {
			raise new Error('Function name() has not been implemented.');
		}
	}
	
	class Report {
		array groups;
		array keys;
		array result;
		array totals;
		object previousGroup;
		number startTime;
		number endTime;
		object timeFormat;
		array channels;
		array organisations;
		array areas;
		array users;

		function addGroup( object group ) {
			.groups[] = group;
			if( .previousGroup )
				.previousGroup.setNextGroup(group);
			.previousGroup = group;
			group.setStartTime(.startTime);
			group.setEndTime(.endTime);
			group.setTimeFormat(.timeFormat);
		}
		function addKey( object key ) {
			.keys[] = key;
		}
		function firstKey() {
			if( .keys )
				return .keys[0];
			return null;
		}
		function firstGroup() {
			if( .groups )
				return .groups[0];
			return null;
		}

		function setStartTime( number time ) {
			.startTime = time;
			.groups.each() using ( group ) {
				group.setStartTime(time);
			};
		}

		function setEndTime( number time ) {
			.endTime = time;
			.groups.each() using ( group ) {
				group.setEndTime(time);
			};
		}

		function setTimeFormat( object format ) {
			.timeFormat = format;
			.groups.each() using ( group ) {
				group.setTimeFormat(format);
			};
		}

		function setChannels( array list )
			.channels = list;

		function setOrganisations( array list )
			.organisations = list;

		function setAreas( array list )
			.areas = list;

		function setUsers( array list )
			.users = list;

		function buildQuery( object key, array groups, boolean buildReport ) {
			array select = [];
			array from = [];
			array where = [];
			array groupBy = [];
			array orderBy = [];
			
			from[] = key.from();
			
			if( key.where() ) where[] = key.where();
			
			where[] = key.columnTime() + ' >= ' + .startTime;
			where[] = key.columnTime() + ' <= ' + .endTime;

			if( .channels ) where[] = key.columnChannel() + ' in (' + .channels.join(',') + ')';
			if( .organisations ) where[] = key.columnOrganisation() + ' in (' + .organisations.join(',') + ')';
			if( .areas ) where[] = key.columnArea() + ' in (' + .areas.join(',') + ')';
			if( .users ) where[] = key.columnUser() + ' in (' + .users.join(',') + ')';

			if( buildReport ) {
				select[] = key.select();
			} else {
				select[] = key.columnData() + ' AS key';
				orderBy[] = key.columnData();
			}

			groups.each() using ( group ) {
				select[] = group.select(key);
				if( group.from() ) from[] = group.from();
				if( group.where(key) ) where[] = group.where(key);
				groupBy[] = group.groupBy();
				orderBy[] = group.orderBy();
			};

			return 'SELECT ' + select.join(', ') +
				' FROM ' + from.join(', ') +
				(where ? ' WHERE ' + where.join(' AND ') : '') +
				(buildReport ? ' GROUP BY ' + groupBy.join(', ') : '') +
				' ORDER BY ' + orderBy.join(', ');
		}
		
		function valuesForKey( object key, array& extra, boolean buildReport ) {
			string query;
			number size;
			array tempResult;
			string name;

			Statistics.resetOrderID();

			query = .buildQuery(key, .groups, buildReport);
			Console.printlnErr("(debug) ${query}");

			name = 'key_' + key.identifier();

			size = .result.size();
			for( number i = 0; i < size; ++i )
				.result[i][name] = 0;

			tempResult = Database.queryAllResults(query);

			if( buildReport ) {
				size = tempResult.size();
				for( number i = 0; i < size; ++i ) {
					number value = (tempResult[i]['key'] isa string
						? tempResult[i]['key'].toNumber()
						: tempResult[i]['key']);
					.result.setRow(tempResult[i], name, value, extra);

					if( not .totals.keyExists(name) )
						.totals[name] = 0;
					.totals[name] += value;
				}
			} else {
				.result = tempResult;
			}
		}

		function build( boolean buildReport ) {
			array extra;

			.groups.each() using ( group ) {
				extra = extra.append(group.extra());
			};

			.result = .firstGroup().build();

			.keys.each() using ( key ) {
				.valuesForKey(key, extra, buildReport);
			};

			for( number i = 0; i < .result.size(); i++ ) {
				.groups.each() using ( group ) {
					if( group.needTranslation() ) {
						string name = group.groupName();
						.result[i][name] = I(.result[i][name]);
					}
				};
			};

//			Console.printlnErr('[DEBUG] ------------------- RESULT --------------------------');
//			Console.printlnErr('[DEBUG] ' + .result);
//			Console.printlnErr('[DEBUG] -----------------------------------------------------');
		}

		function buildReport() {
			.build(true);
		}

		function buildData() {
			.build(false);
		}

		function run() {
			.buildReport();
		}

		function toHTML() {
			object formatter = new Statistics.HTMLFormatter();
			return formatter.run(.groups.append(.keys), .result, .totals);
		}

		function toJSON( boolean linesChart ) {
			// [
			// 		'labels' => [ 'May', 'June', 'July', 'August', 'September' ],
			//		'data' => [
			//			[ ], // Email
			//			[ ]  // Manual
			// 		]
			// ]

			number lastGroupIndex = .groups.size() - 1;
			object lastGroup = .groups[lastGroupIndex];
			string lastGroupName = lastGroup.groupName();
			number nextToLastGroupIndex = lastGroupIndex - 1;
			object nextToLastGroup = .groups[nextToLastGroupIndex];
			string nextToLastGroupName = nextToLastGroup.groupName();

			string groupName;
			//array haveLabels = [];
			array labels = [];
			array data = [];
			array dataNames = [];

			number size;

			//number size = .result.size();

			//for( number i = 0; i < size; ++i ) {
			//	string group = .result[i][nextToLastGroup];
			//	if( not haveLabels.keyExists(group) ) {
			//		labels[] = groups;
			//		haveLabels[group] => true;
			//	}
			//}

			//for( number i = 0; i < size; ++i ) {
			//
			//}

			if( linesChart ) {
				if( .groups.size() > 1 ) {

				} else {
					labels = lastGroup.values();
					data[] = [];
					groupName = lastGroupName;
				}
			} else {
				if( .groups.size() > 1 ) {
					labels = nextToLastGroup.values();

					lastGroup.values().each() using( value ) {
						data[] = [];
						dataNames[value] = true;
					};

					groupName = nextToLastGroupName;
				} else {
					labels = [ lastGroup.name() ];

					lastGroup.values().each() using( value ) {
						data[] = [];
						dataNames[value] = true;
					};

					groupName = lastGroupName;
				}
			}

			if( data.size() == 0 )
				data[] = [];

//			Console.printlnErr('[DEBUG] -----------------------------------------------------');
//			Console.printlnErr('[DEBUG] data: ' + data);
//			Console.printlnErr('[DEBUG] data.size(): ' + data.size());
//			Console.printlnErr('[DEBUG] dataNames: ' + dataNames);
			
			size = .result.size();
			for( number i = 0; i < size; ++i ) {
				number index = dataNames.getIndex(.result[i][groupName]);
//				Console.printlnErr('[DEBUG] index: ' + index);
//				Console.printlnErr("[DEBUG] Result (${i}): " + .result[i]);
				if( index >= 0 and index < data.size() ) {
					for( number j = 0; j < .result[i].size(); j++ ) {
						if( .result[i].getName(j).index('key_') == 0 )
							data[index][] = .result[i][j];
					}
				} else {
					for( number j = 0; j < .result[i].size(); j++ ) {
						if( .result[i].getName(j).index('key_') == 0 )
							data[0][] = .result[i][j];
					}
				}
			}

			/* data[] = [];
			data[1][] = 873; */	

//			Console.printlnErr('[DEBUG] -----------------------------------------------------');

			return JSON.valueToJSON([
					'labels' => labels,
					'data' => data
				]);
		}

		function getTotal( number index ) {
			number total = 0;
			number size = .result.size();
			for( number i = 0; i < size; ++i ) {
				for( number j = 0; j < .result[i].size(); j++ ) {
					string name = .result[i].getName(j);
					if( name.index('key_') == 0 ) {
						total += .result[i][j];
					}
				}
			}
			return total;
		}
	}

	number _nextGroupID;
	function nextGroupName() {
		string name = 'group' + ._nextGroupID;
		._nextGroupID++;
		return name;
	}

	number _nextOrderID;
	function nextOrderName() {
		string name = 'order' + ._nextOrderID;
		._nextOrderID++;
		return name;
	}
	
	function resetGroupID()
		._nextGroupID = 0;
	function resetOrderID()
		._nextOrderID = 0;

	/*
	function groupRows( array& rows ) {
		array report = [];
		rows.each() using ( row ) {
			array path = [];
			for( number i = 0; i < row.size(); i++ ) {
				if( row.getName(i).index('group') == 0 )
					path[] = row[i].trim(' ');
			}
			report.setPath(path, row['key']);
		};
		return report;
	}
	*/
	
	/*
	<table>
		<tr>
			<td rowspan="4">Area 1</td>
			<td rowspan="2">2012</td>
			<td>November</td>
			<td>15</td>
		</tr>
		<tr>
			<td>December</td>
			<td>24</td>
		</tr>
		<tr>
			<td rowspan="2">2013</td>
			<td>January</td>
			<td>12</td>
		</tr>
		<tr>
			<td>Februari</td>
			<td>31</td>
		</tr>
	</table>
	
	[ 'Area 1' => [ '2012' => [ 'November' => 15,
	                            'December' => 24
	                          ],
	                '2013' => [ 'January' => 12,
	                            'Februari' => 31
	                          ]
	              ]
	]
	
	
	
	*/
	
	class HTMLRow {
		array columns;
		function addColumn( object column ) {
			if( not .columns )
				column.first = true;
			.columns[] = column;
		}
		function render() {
			array html = [];
			html[] = '<tr valign="top">';
			.columns.each() using ( column ) {
				if( column.render ) {
					array cssClasses = [];
					column.first and cssClasses[] = 'first';
					column.group and cssClasses[] = 'group';
					html[] = '<td' +
						(cssClasses ? ' class="' + cssClasses.join(' ') + '"' : '') +
						(column.rowspan > 1 ? ' rowspan="' + column.rowspan + '"' : '') +
						'>' + column.value.trim(' ') + '</td>';
				}
			};
			html[] = '</tr>';
			return html.join('');
		}
	}
	class HTMLColumn {
		string value = '';
		number rowspan = 1;
		boolean first = false;
		boolean group = false;
		boolean render = false;
	}
	class HTMLFormatter {
		function run( array headers, array& report, array& totals ) {
			array html;
			array rows;
			array list;
			
			object previousRow;
			number groups;
			
			report.each() using ( data ) {
				object row = new Statistics.HTMLRow();
				array values = [];
				array keyValues;
				
				for( number i = 0; i < data.size(); i++ ) {
					if( data.getName(i).index('group') == 0 ) {
						values[] = String.trim('' + data[i], ' ');
					} else if( data.getName(i).index('key') == 0 ) {
						keyValues[] = String.trim('' + data[i], ' ');
					}
				}
				
				values.each() using ( value ) {
					object column = new Statistics.HTMLColumn();
					column.group = true;
					column.value = value;
					row.addColumn(column);
				};
				
				keyValues.each() using ( keyValue ) {
					object column = new Statistics.HTMLColumn();
					column.value = keyValue;
					row.addColumn(column);
				};
				
				rows[] = row;
			};
			
			rows.each() using ( row ) {
				row.columns.eachWithIndex() using ( column, index ) {
					//Console.println('---------------------------------------');
					if( previousRow ) {
						if( column.group ) {
							//Console.println('Previous column: "' + previousRow.columns[index].value + '"');
							//Console.println('         column: "' + column.value + '"');
							//Console.println('Old: "' + previousRow.columns[index].value + '"');
							//Console.println('New: "' + column.value + '"');
							if( previousRow.columns[index].value == column.value ) {
								//Console.println('Previous column: "' + previousRow.columns[index].value + '"');
								//Console.println('         column: "' + column.value + '"');
								if( not list.keyExists(column.value) ) {
									//Console.println('Not found: ' + column.value);
									list[column.value] = column;
									column.render = true;
								}
								if( list[column.value] ) {
									list[column.value].rowspan++;
								} else {
									list[column.value] = column;
									column.render = true;
								}
								//Console.println(column.value + ': ' + list[column.value].rowspan);
							} else {
								//Console.println('Old: "' + previousRow.columns[index].value + '"');
								//Console.println('New: "' + column.value + '"');
								for( number i = index; i < previousRow.columns.size(); i++ ) {
									if( previousRow.columns[i].group ) {
										string value = previousRow.columns[i].value;
										//Console.println("Deleting: '${value}'");
										if( list.keyExists(value) ) {
											//Console.println('Yes');
											list.del(value);
										} else {
											//Console.println('No');
										}
										list[row.columns[i].value] = null;
										//list[row.columns[i].value] = row.columns[i];
										//list[row.columns[i].value].render = true;
									}
								}
								column.render = true;
								list[column.value] = column;
							}
						} else {
							column.render = true;
						}
					} else {
						if( column.group )
							list[column.value] = column;
						column.render = true;
					}
				};
				previousRow = row;
			};
			
			html[] = '<table border="0" cellpadding="0" cellspacing="0" class="ReportsTable">';
			html[] = '<tr>';
			headers.eachWithIndex() using ( item, index ) {
				if( index == 0 ) html[] = '<th class="first">' + item.name() + '</th>';
				else             html[] = '<th>' + item.name() + '</th>';

				if( item.isGroup() )
					groups++;
			};
			html[] = '</tr>';
			rows.each() using ( row ) {
				html[] = row.render();
			};
			html[] = '<tr>';
			html[] = '<td class="first group" colspan="' + groups + '">' + I('Total') + '</td>';
			headers.each() using ( item ) {
				if( not item.isGroup() ) {
					string id = 'key_' + item.identifier();
					html[] = '<td>' + totals[id] + '</td>';
				}
			};
			html[] = '</tr>';
			html[] = '</table>';

			return html.join("\n");
		}
	}
}
